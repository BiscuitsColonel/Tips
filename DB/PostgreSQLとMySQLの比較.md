# オープンソースRDBのデファクトスタンダードのPostgreSQLとMySQLの長所・短所
1. DDL操作のノンブロッキング
2. DML文のパフォーマンス
3. テーブル結合(JOIN)のアルゴリズム
4. トランザクション処理の分離レベル
5. ストアドプロシージャ、トリガー
6. レプリケーションの論理型と物理型
7. どちらかのDBだけにある便利機能
8. データ型のゆるさ、型変換、文字列比較
9. 結論:どっちをどんなサービスに使うべき?

# 1. DDL操作のノンブロッキング
## 1-1. MySQL
多くのDDL操作をノンブロッキング(トランザクション中でもテーブルへのブロックがかからない)で実行できる。  
対象のカラムのみをスキャンするようなALTER TABLE(カラム名を変更する、カラムを追加するなど)の場合、テーブルをゼロからリビルドしないため処理速度が速く、サーバー全体の負荷が低減できる。

## 1-2. PostgreSQL
ALTER TABLEなどのDDL操作はノンブロッキングではなく、どのようなDDL文を発行するかによっても変わってくる。  
たとえばカラムを追加するなどテーブルを書き換える操作は、テーブルへのブロックが発生してしまい、参照もできなくなってしまう。  
本番環境のDBに対してALTER TABLEをかけたい場合は、pg_repackというメンテナンス用の外部ツールが使用されることが多い。  
それを使えば、REINDEXや一部のALTER TABLE操作を最小限のロックで実行できる。

# 2. DML文のパフォーマンス
## 2-1. SELECT文
シンプルなSELECTなら、MySQLもPostgreSQLもそれほど変わらない。  
ただし、大量データのソートが必要なSELECT(ORDER BYをしたうえで、テーブルの全データを取得するなど)はMySQLだと遅くなる。  
なぜなら、PostgreSQLと比較するとMySQLはソートのアルゴリズムがそれほど優れていない。  
MySQLは、大量データをソートすることを、基本的にユースケースとして想定していない。  
MySQLは、新規10件とか100件のデータ(TOP n レコード)を取得するような、たとえばTwitterのようなユースケースに特化している。  
そういった場面では、PostgreSQLよりも速い。
## 2-2. UPDATE文
MySQLの方がパフォーマンスに優れている。  
PostgreSQLは追記型アーキテクチャで、UPDATEする際にはINSERTに近い処理が実行されている。  
つまり、変更前の行に削除フラグのようなものを立てたうえで、変更後のデータを持った新しい行を追加している。  
一方でMySQLは、UPDATE対象となる行の値を直接上書きしている。文字通りに“更新"している。
## 2-3. DELETE文
かつて、MySQLにはDELETEが遅いという欠点があった。これは、データ削除後にセカンダリーインデックス(クラスタインデックス以外のすべてのインデックス)を同期処理で貼り直しており、その処理に時間がかかっていたためである。  
しかし、バージョン5.5でかなり解消され、セカンダリーインデックスの非同期のチェンジバッファ(セカンダリーインデックスエントリへの変更をバッファリングしておき、サーバがアイドル状態にあるときなどに変更内容をマージする仕組み)が効くようになったため、以前ほど「DELETEが遅い」ということはなくなった。

# 3. テーブル結合(JOIN)のアルゴリズム
よく使われるテーブル結合のアルゴリズムには「ネステッドループ結合(Nested Loop Join)」「ハッシュ結合(Hash Join)」「ソートマージ結合(Sort Merge Join)」の3種類がある。

## 3-1. MySQL
基本的にネステッドループ結合しかサポートしていない。  
なぜなら、MySQLは「複雑なアルゴリズムはなるべくサポートしない」という設計思想に基づいている。  
Webアプリケーションに使われるようになる前に、MySQLはもともと組み込み系のシステムで使われていたことに起因している。  
組み込み機器の非常に容量が小さいディスクやメモリの中でDBを稼働させる必要があり、複雑なアルゴリズムをなるべくそぎ落とす方針で設計されてきた。

## 3-2. PostgreSQL
3種類ともサポートしている。

### 3-3-1. ハッシュ結合やソートマージ結合
結合対象のデータ量が多い場合。そのデータが既にソートされている場合にはソートマージ結合の方がよく、そうでなければハッシュ結合がおすすめである。

### 3-3-2. ネステッドループ結合(MySQLにおいても同様)
結合されるテーブルどちらかのデータ量が少なくてもう一方が多いようなとき。  
インナーテーブル側がインデックススキャンを使える場合など。

# 4. トランザクション処理の分離レベル
PostgreSQLとMySQLでは、それぞれのデフォルトのトランザクション分離レベル(トランザクション処理が複数同時に実行された場合に、どれほどのデータ一貫性・正確性で実行するかを定義したもの)が異なっている。

## 4-1. MySQL
デフォルトがREPEATABLE-READとなっているため、読み取り対象のデータが途中で他のトランザクションから変更されてしまう心配はない。  
ただし、ファントムリード(並行して動作している他のトランザクションが追加したデータが途中で見えてしまう現象)が起こる可能性がありる。  
MySQLでは、このファントムリードを避けるため、ネクストキーロックという仕組みを採用している。  
これはトランザクションが走っている最中にレコードが増えないよう、主キーのインクリメント先の値までロックをかけるというものである。  
この仕組みによってデータの堅牢性は保たれるが、同時にこれが原因で意図せぬロックがかかり、トラブルの原因になってしまうこともある。  
たとえば、SELECT FOR UPDATEなどでWHERE句に「<(不等号)」を使用し、「IDが10以上」のレコードを検索したとする。  
すると、10以上のキーが全てロックされてしまう。こうなってしまうと新たな主キーが生成できず、INSERTできなくなってしまう。  
この仕様はけっこうハマりどころなので、注意しておいた方がいい。
ロック競合を減らすため、トランザクション分離レベルを、より低いREAD-COMMITTED(常にコミット済みの最新データを読み取る形式)に変更して運用するケースもある。

## 4-2. PostgreSQL
デフォルトのトランザクション分離レベルはREAD-COMMITTEDである。  
この方式の場合、ファントムリードやノンリピータブルリード(同じトランザクション中でも同じデータを読み込むたびに値が変わってしまう現象)が起こる可能性があるため、運用ではその点に気をつける必要がある。  
また、トランザクション分離レベルをREPEATABLE-READに変更したとしても、ネクストキーロックを取らず、違う方法でファントムリードを防いでいる。  
そのため、ロック競合を防ぎやすいという点はMySQLよりも優れているかもしれない。

# 5. ストアドプロシージャ、トリガー
## 5-1. ストアドプロシージャ
### 5-1-1. PostgreSQL
SQL以外にもPythonなどを利用した外部プロシージャが使える利点がある。
### 5-1-2. MySQL
MySQL単体ではストアドプロシージャのステップ実行ができないという欠点がある。

## 5-2. トリガー
### 5-2-1. MySQL
5.6以前では、1テーブルにつき最大6つまでしかマルチトリガーが仕掛けられないという欠点があった。  
また、BEFORE INSERT TRIGGERが1テーブルにつき1個しか仕掛けられなかったため、かなり制限があった。  
現在では、トリガー個数の制限はなくなっている。  
ただし、MySQLのトリガーはFOR EACH ROWしかなくてFOR EACH STATEMENTがないため、その点は考慮しておく必要がある。

# 6. レプリケーションの論理型と物理型
## 6-1. MySQL
レプリケーションは論理型(SQL文そのものをコピー)または物理型(変更後の行イメージをコピー)のいずれかを選べるようになっている。  
従来は論理型がデフォルト設定だったが、MySQL 5.7以降では物理型がデフォルトになった。  
論理型は良くも悪くも柔軟なところがあって、たとえばマスターのテーブルとスレーブのテーブルのスキーマが多少違っていたとしても、SQLさえ通ってしまえばエラーにならない。  
その仕様を利用してカジュアルな運用ができるという良さはあるが、マスターとスレーブに差異があっても検知できない可能性があるのは、データ堅牢性の面から見ると課題がある。  
このため「安全側をデフォルトにする」という思想から、物理型がデフォルトになった。
## 6-2. PostgreSQL
物理型のみ。  
ただ、現在ベータ版としてリリースされているバージョン10からは論理型も使えるようになっている。

# 7. どちらかのDBだけにある便利機能
## 7-1. PostgreSQL
### 7-1-1. パラレルクエリ
処理速度をより速くするために、複数のCPUを活用してクエリを実行する。

### 7-1-2. PostGISというサードパーティのOSSツール
地図や幾何データの情報を扱うためのもの。MySQLのものより機能が豊富で、PostgreSQLが持つアドバンテージのひとつである。

### 7-1-3. pg_basebackup
オンラインかつリモートでデータベースクラスタのベースバックアップが取れる。  
MySQLの場合は、オンラインでの物理バックアップの手段がXtraBackupもしくはEnterprise Backupしかないので、オンラインかつリモートではベースバックアップを実行できない。

### 7-1-4. その他
これまでは、部分的に切り出した結果セットに集約関数を適用できるウィンドウ関数や、SELECT文の実行前にサブクエリを作成できるWITH句など、集計に適した機能があった。  
ただ、ウィンドウ関数もWITH句も、MySQLでもバージョン8.0から導入される予定である。

# 8. データ型のゆるさ、型変換、文字列比較(暗黙的に実施される型変換や、文字列比較の厳格さなど)
## 8-1. データ型のゆるさ
### 8-1-1. MySQL
バージョン5.6以前では、データ型のゆるさが問題になることが多かった。  
でも、5.7からは全体的にカタい方に修正されて、以前よりはデータ型が原因でバグが発生するケースが少なくなった。  
しかし、いくつか気をつけるべきユースケースが存在している。
```
ex. (int) 1 = (string) '1' = (string) '1Q84'
```
MySQLの場合、この3つは「同じ値である」と認識される。  
なぜかというと、数字の「1」と文字列の「1」を比較するとき、暗黙的に文字列から数字への型変換がされる。だから、1つ目と2つ目は同じ値として認識される。  
そして、数値の「1」と文字列の「1Q84」を比較する際にも、「1Q84」を数値へ暗黙的に型変換する。  
すると、データを前方から読みこんでいって、数値として認識できる部分まで型変換する。  
つまり「1Q84」の「1」までが読みこまれると、「同じ値である」と認識されてしまう。  
他にも暗黙的に型変換されるケースがあって、たとえば日付型の「2017-07-01」から数字の「1」を引くと「20170700」という整数が返る。  
バグの原因になりやすい仕様なので、MySQLを使う場合は気をつけた方がいい。
### 8-1-2. PostgreSQL
各種の型変換に関してはかなりカタい方に寄せている。  
文字列型から数値型への暗黙的な型変換は起こらないので、SQLを書く人が明示的にキャストしなければいけない。  
もしくは、暗黙型変換をユーザが定義することで対応する方法もある。
## 8-2. 文字列比較
### 8-2-1. MySQL
デフォルト設定では文字列比較において大文字小文字の区別をしない。  
また、バージョン8.0からは、デフォルト設定だと濁音と半濁音を区別しなくなる。  
「は」と「ぱ」と「ば」はイコールになるし、「びょういん」と「びよういん」もイコールになる。  
その仕様なのは、Unicodeの仕様に依存している。Unicodeは、照合順序(並べ替え)の厳格さの設定が、レベル1からレベル4まで段階的に分かれている。  
「は」と「ぱ」と「ば」を区別するためにはレベル2以上の比較が、「びょういん」と「びよういん」を区別するためにはレベル3以上の比較が必要なのですが、MySQLのデフォルト設定では1レベルしか使わない比較になっている。  
レベルを上げれば文字列の区別は正確になるが、処理は重たくなってくる。  
MySQLは「シンプルな処理を高速にする」という設計思想に基づいてつくられているので、処理スピードを捨ててまで文字列比較の厳格さを取るようなことはしない。

# 9. 結論
バージョンが上がるごとにPostgreSQLもMySQLも高性能になってきているので、結局は使いたい方を使えばいいけど...

## 9-1. PostgreSQL
### 9-1-1. 多機能であること
この特徴が生きるようなシステムには向いている。  
たとえば、Oracle Databaseからの移行やSIer系の企業で使われるケースが多い。
### 9-1-2. 分析系のシステムでもよく使われる
これも前述のようにMySQLの分析機能が徐々に充実してきているため、将来的に差は少なくなってくる。
### 9-2. MySQL
基本的には、シンプルなWebサービスに向いている。  
一定数の結果セットを取ってきて、そのデータを表示するといった感じのサービス。  
たとえばTwitterのように、タイムラインの先頭部分を表示して、下にスクロールすると次のデータを読みこむようなサービスは、MySQLには特にマッチしている。  